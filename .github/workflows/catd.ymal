name: ä¸ƒçŒ«å°è¯´ TXT ä¸‹è½½å™¨

on:
  workflow_dispatch:
    inputs:
      novel_id:
        description: 'å°è¯´ IDï¼ˆä¸ƒçŒ« URL ä¸­çš„æ•°å­—ï¼‰'
        required: true
        default: '1673946'
      threads:
        description: 'å¹¶å‘çº¿ç¨‹æ•° 1-10'
        required: true
        default: '5'
      format:
        description: 'è¾“å‡ºæ ¼å¼'
        required: true
        type: choice
        options:
          - txt
          - epub
        default: 'txt'

permissions:
  contents: write
  actions: read

jobs:
  download:
    runs-on: ubuntu-latest
    steps:
      - name: æ£€å‡ºä»“åº“
        uses: actions/checkout@v4

      - name: å®‰è£… Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: å®‰è£…ä¾èµ–
        run: |
          python -m pip install --upgrade pip
          pip install requests beautifulsoup4 fake-useragent tqdm

      - name: è¿è¡Œçˆ¬è™«
        env:
          NOVEL_ID: github.event.inputs.noveliâ€‹dTHREADS:{{ github.event.inputs.threads }}
          FORMAT: ${{ github.event.inputs.format }}
        run: |
          cat > download.py <<'PY'
import os, re, time, json, math
import requests, concurrent.futures
from bs4 import BeautifulSoup
from tqdm import tqdm
from fake_useragent import UserAgent

NOVEL_ID   = os.getenv('NOVEL_ID', '1673946')
THREADS    = int(os.getenv('THREADS', 5))
OUT_FORMAT = os.getenv('FORMAT', 'txt')

ua   = UserAgent()
sess = requests.Session()
sess.headers.update({'User-Agent': ua.random})

def get_chapter_list():
    url = f'https://www.qimao.com/reader/index/{NOVEL_ID}/'
    html = sess.get(url, timeout=15).text
    soup = BeautifulSoup(html, 'lxml')
    title = soup.select_one('.book-title').get_text(strip=True)
    lis = soup.select('.chapter-list li a')
    return title, [(a['href'], a.get_text(strip=True)) for a in lis]

def fetch_chapter(link):
    url = f'https://www.qimao.com{link}'
    html = sess.get(url, timeout=15).text
    soup = BeautifulSoup(html, 'lxml')
    content = soup.select_one('.chapter-content')
    if not content:
        return ''
    return '\n'.join(p.get_text(strip=True) for p in content.select('p'))

def main():
    book_title, chapters = get_chapter_list()
    print(f'ðŸ“š {book_title} å…± {len(chapters)} ç« ')
    lines = [f'# {book_title}\n\n']
    with concurrent.futures.ThreadPoolExecutor(max_workers=THREADS) as ex:
        futures = {ex.submit(fetch_chapter, link): idx for idx, (link, _) in enumerate(chapters)}
        for future in tqdm(concurrent.futures.as_completed(futures), total=len(chapters)):
            idx = futures[future]
            text = future.result()
            lines.append(f'## ç¬¬{idx+1}ç«  {chapters[idx][1]}\n{text}\n\n')
    fname = f'{book_title}.{OUT_FORMAT}'
    with open(fname, 'w', encoding='utf-8') as f:
        f.writelines(lines)
    print(f'âœ… å·²ä¿å­˜ {fname}')

if __name__ == '__main__':
    main()
PY
          python download.py

      - name: ä¸Šä¼ æˆå“
        uses: actions/upload-artifact@v4
        with:
          name: novel-${{ github.event.inputs.novel_id }}-github.event.inputs.formatpath:â€²âˆ—.{{ github.event.inputs.format }}'
          retention-days: 7
